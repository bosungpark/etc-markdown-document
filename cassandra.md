Cassandra - A Decentralized Structured Storage System... Avinash Lakshman, Prashant Malik
=

카산드라는 구조화된 대용량 데이터를 저장하는 분산 저장소이다.
완전한 관계형 데이터 모델을 제공하지는 않지만, 데이터의 포맷과 레이아웃을 동적으로 제어할 수 있는 단순한 데이터 모델을 제공한다.

성능과 고가용성 내결함성 등을 위해 분산 데이터 시스템을 사용하는 것은 널리 알려져 있다.
1차원적인 네임스페이스만을 제공하는 P2P와 달리, 분산 파일 시스템은 계층적인 네임스페이스를 제공한다.
충돌에 대한 대응 방식은 시스템의 특성마다 다르지만, 궁극적 일관성을 보장한다.
기존의 관계형 데이터베이스들이 레플리카들에 제공하던 강한 일관성 모델은 편리한 면이 있지만, 확장성과 가용성 측면에서 한계가 있다.
또 이런 관계형 데이터베이스 들은 강한 일관성을 제공하기 때문에 네트워크 결함에는 약한 모습을 보인다.

다이나모는 가쉽 베이스 알고리즘을 사용한다. 모든 노드 들은 모든 다른 노드들에 대한 정보를 알고 있다.
다이나모는 vector clock scheme을 사용해 업데이트 된 데이터의 충돌을 감지하지만, 클라이언트 사이드의 충돌 해결을 선호한다.
이는 쓰기 연산이 매우 많은 제한적인 환경에서 사용될 만 하다.

DATA MODEL
-
카산드라의 테이블은 키에의해 색인된 다차원 맵의 구조를 가지고 있다.
로우의 키는 크기의 제한이 없는 문자열로 이루어져 있다.(일반적으로는 16 to 36 bytes)
하나의 로우가 가지는 연산은 컬럼의 수와 무관하게 레플리카 안에서의 원자성을 보장한다.
컬럼들은 column families라고 불리는 단위로 묶인다. 
카산드라는 두 종류의 column families를 제공한다.

- Simple column families: 컬럼을 포함할 수 있는 컬럼
- Super column families: 

SYSTEM ARCHITECTURE
-
Partitioning: 
클러스터의 노드 사이에서 동적으로 파티셔닝할 수 있다는 특징. 클러스터는 안정 해싱을 사용한다. 
안정 해싱은 전통적인 해싱기법과 달리 모듈러 연산을 사용하지 않고 원형 테이블에 노드와 숫자를 배치한 뒤, 시계방향으로 가장 가까운 경우에 짝을 지어주는 방식이다.
전통적인 해싱 기법에 비해 바로 근처에 있는 노드에만 영향을 주기 때문에 사이즈가 변할 때 대규모 캐시미스를 예방할 수 있다는 장점이 있다.

하지만 노드간의 무작위의 포지셔닝은 데이터와 로드의 불균일한 분배의 원인이라는 단점이 있다. 

Replication:
카산드라는 N개의 노드를 가지며 그 중 k개는 코디네이터 노드(클라이언트가 접근권을 가진 노드). 
코디네이터 노드는 데이터 복제의 책임을 가지고 있으며 자신을 제외한 최대 N-1개의 노드에 전달한다.
이를 통해 각지의 데이터 센터에 위치한 노드들은 상대적으로 안정적이게 유지될 수 있다.
책임 범위등에 대한 메타테이터는 Zookeeper에서 캐싱하여, 노드가 죽었다 살아나도 책임의 범위를 알 수 있게 한다.

Membership:
카산드라의 클러스터 멤버십은 가쉽 알고리즘에 기반을 두고 있다.
카산드라의 가쉽 알고리즘은 CPU 활용과 가쉽체널에 현저한 장점을 가진다.

Failure Detection은 다른 노드가 살았는지 죽었는지를 탐지하는 시스템이다. 
신뢰할 수 없는 경로를 통해 정보를 전달하는 방법이다.(전체에게 알리지 않아도 전체가 알게 되는 것)
주기적으로 상태를 체크하고 일정시간 연락이 없으면 죽었다고 판단한다. 
단순한 Failure Detection에서 한 발짝 더 나아간 탐지 기법으로는 Accrual Failure Detector가 있다.
Accrual Failure Detector는 application과 decoupling 됨, suspicion level과 네트워크 변동 등을 고려한다는 특징 들이 추가된 방식이다.

Bootstrapping:
노드가 처음 시작할 때에는 링에서의 포지션에 대한 무작위 토큰을 발급받는다. 그리고는 토큰에 대한 정보는 노드들 사이에 가쉽된다.

Scaling the Cluster:
새로운 노드가 시스템에 추가되면 토큰을 부여받고 과중된 로드를 분산한다.
이렇게 되면 기존의 특정 노드가 가지고 있던 책임범위를 분할하는 결과를 가져온다.

Local Persistence:
카산드라는 저장을 위해 로컬의 파일 시스템에 의존한다.
in-memory data structure에 저장되는 것은 커밋로그가 정상적으로 쌓인 이후에 가능하다.
모든 쓰기연산은 시퀀셜하게 인덱스와 함께 이루어지고 머지의 과정을 거친다.
파일은 최근 데이터에서 오래된 순으로 읽는다.

