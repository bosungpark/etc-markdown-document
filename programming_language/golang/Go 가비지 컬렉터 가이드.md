Go 가비지 컬렉터 가이드
=

https://tip.golang.org/doc/gc-guide

GC에서 관리할 필요가 없는 메모리
-
지역 변수에 저장된 포인터가 아닌 Go 값은 Go GC에서 전혀 관리되지 않을 가능성이 높다.
대신 GO는 스코프 안에 있는 메모리가 연결되게 할당한다.
일반적으로 이 방법은 GC에 의존하는 것보다 효율적이다.
Go 컴파일러는 해당 메모리가 해제될 시기를 미리 결정하고 정리할 수 있기 때문이다.
일반적으로 Go 값에 대한 메모리 할당은 이와같은 스택할당이다.

하지만 Go 컴파일러가 수명을 결정할 수 없기 때문에 이러한 방식으로 메모리를 할당할 수 없는 Go 값은 heap으로 이동한다.
힙에 메모리를 할당하는 행위는 일반적으로 "동적 메모리 할당"이라고 한다.

가비지 컬렉션 추적
-
live 개체를 식별한다.

Object - 객체는 하나 이상의 Go 값을 포함하는 동적으로 할당된 메모리 조각

포인터 - 객체 내의 모든 값을 참조하는 메모리 주소 (문자열, 슬라이스, 채널, 맵 및 인터페이스 값에는 모두 GC가 추적해야 하는 메모리 주소가 포함)

1. 객체와 다른 객체에 대한 포인터가 함께 객체 그래프를 형성
2. 이브 메모리를 식별하기 위해 GC는 프로그램에서 확실히 사용 중인 객체를 식별하는 포인터인 프로그램 루트(지역/전역 변수) 에서 시작하여 객체 그래프를 탐색
3. 마크 앤 스왑 (행 상황을 추적하기 위해 GC가 발견한 값을 실시간으로 표시)

GOGC
-
GC의 목표는 총 힙 크기가 대상 힙 크기를 초과하기 전에 수집 주기를 완료하는 것
Go GC는 완전히 멈추는 것이 아니며 대부분의 작업을 애플리케이션과 동시에 수행한다.

웹 서비스에서는 처리량(예: 초당 쿼리)이 여전히 중요하지만 각 개별 요청의 대기 시간이 훨씬 더 중요한 경우가 많다.
대기 시간 측면에서 마크 앤 스왑에는 많은 시간이 걸리고 , 이 기간 동안 애플리케이션과 웹 서비스 컨텍스트에서는 진행 중인 요청을 수행할 수 없다.

이를 보완하기 위해, Go는 heap의 크기에 따라 과도한 지연을 방지하기 위해 마크 단계에서 동시적인 데이터 수집을 하여고 비록 처리량은 다소 떨어지지만 괜찮은 성과를 보였다 주장함,,,,,.....
