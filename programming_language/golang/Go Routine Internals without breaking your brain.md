Go Routine Internals without breaking your brain
=

https://youtu.be/O4aTkRQAK-o?si=X5RQcV-ThACFOKXr

동시성
-

<img width="285" alt="스크린샷 2024-06-15 오후 8 43 57" src="https://github.com/bosungpark/jumble-markdown-document/assets/81157873/65a461ad-5cad-4cc5-b2cd-8503fc21f855">

OS는 프로그램을 운용하기 위한 프로세스의 추상화를 제공한다.
그리고 하나의 CPU 코어는 하나의 명령을 한번에 처리해야한다.

그래서 동시성과 관련하여 스케쥴링이라는 개념이 등장한다.

<img width="338" alt="스크린샷 2024-06-15 오후 8 46 35" src="https://github.com/bosungpark/jumble-markdown-document/assets/81157873/8025d206-8574-4d4c-bff0-6efca38966e3">

한 번에 하나의 명령이 처리되어야 한다는 제약조건은 그대로 유지되지만, 빠르게 교차하여 동시에 발생하는 이슈인 것 처럼 눈속임 할 수 있다.

여기까지는 스케쥴러를 이용한 프로세스의 동시성에 대한 이야기였다.
프로세스는 너무 많은 isolation이 존재한다.

isolation을 포기한다면 그에 대한 트레이드-오프로 쓰레드를 사용하는 방법이 있다.
이제 OS의 스케쥴러는 쓰레드에 대한 동시성도 관리 할 수 있게 되었다.

고루틴
-

전통적인 프로그래밍 언어에서는 쓰레드를 spawn한다. 이는 실제 OS 쓰레드를 생성한다는 의미이다.

하지만 실제로 쓰레드를 사용한 동시성 문제 역시 비용이 존재한다는 사실을 알게 된다. 쓰레드의 생성은 메모리가 많이 필요하고 실제로 원하는 만큼의 쓰레드를 만드는 것이 어려울 때도 있다는 것을 알게된다.

그래서 GO는 우리가 필요한 만큼의 수많은 동시적 작업을 위해 스케쥴러에서 사용했던 아이디어를 빌려온다.

프로세스 대신 쓰레드를 사용한 것과 같은 논리가 등장한다.
이제는 쓰레드 대신 고루틴이라는 것이 등장했다는 것이 차이점이다.

고의 런타임 스케쥴러는 쓰레드 풀이라고 부르는 쓰레드 묶음을 생성한다.
여기서부터는 스케쥴러의 동작방식과 같다.

기존 스케쥴러에서 프로세스를 동작시키며 특정 쓰레드가 블록되면 다른 쓰레드를 스케쥴링하는 것처럼, 런타임 스케쥴러는 특정 고루틴이 블록된다면 다음 고루틴을 스케쥴링하는 방식을 취한다.

물론 실제로는 이렇게 단순하지 않고, 엄밀히 같은 원리도 아니지만 러프하게 컨셉을 가져간다면 그렇다는 것이다.

고는 코드의 실행에 대한 많은 컨텍스트를 가지고 있기 때문에 고루틴은 쓰레드에 비해 비교적 경량이다. (대략 500에서 1000배 정도의 차이, 1-2MB >>> 2KB)

고루틴의 동작 원리
-

<img width="412" alt="스크린샷 2024-06-15 오후 9 11 05" src="https://github.com/bosungpark/jumble-markdown-document/assets/81157873/db6ff373-e85f-4fea-9808-9c56a904913f">

고루틴은 글로벌 큐에 일을 쌓아둔다.
각각의 일은 각각의 프로세스에 있는 로컬 큐에 할당된다.

만약 P2와 같이 로컬에 일이 없는 경우, 우선은 글로벌에 일이 있는지 확인한 후 없다면 다른 로컬 큐에 쌓인 일의 절반을 가져와 처리한다.

단순하고 우아한 방식이다.

또 고루틴 스케쥴러는 고루틴을 처리하기 적절한 양의 쓰레드 만을 유지하려고 하기 때문에 리소스 낭비를 막으면서 성능적 이점을 가져갈 수 있다.
